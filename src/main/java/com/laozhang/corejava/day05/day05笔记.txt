回顾:
1.Java基础语法(特点)
2.标示符(哪些,命名规则)
3.数据类型(分类)
4.变量(分类)
5.表达式
6.运算符
7.条件判断语句
8.循环语句
9.数组
10.方法的定义
11.API
-------------------------------------------------------

面向对象基础

OOAD	面向对象的分析与设计
OOP	面向对象的编程

面向对象是一种编程思想,而非一种技术
主要是用来和面向过程的编程思想加以区分

面向对象:
首先找到"对象",接着分析这个"对象",主要体现在这个对象
拥有什么("属性")和能干什么("方法").还要对这些东西归类
("抽象"),为的是找出类之间的关系.最后才是数据结构和算法.

-------------------------------------------------------
Java是一种纯面向对象的编程语言,有如下特点:
1.继承
2.封装
3.多态
4.抽象
...
-------------------------------------------------------
类与对象
什么是类?(Class)
是一种抽象的概念,是对对象的抽象
人类把某一类具有共性的对象抽象为一个类

什么是对象?(Object)
是具体的,是类的实例

类和对象的关系
类是对象的抽象化,对象是类的实例化
所以,JVM一定是先加载类,再创建实例的
-------------------------------------------------------
类的组成

语法:
package xxx.xxx.xxx;

import xxx.xxx.xxx;

public class 类名 {
	//属性的定义

	//构造方法(空参,有参数)

	//对应属性的存取方法

	//[3个方法]
}

属性的定义:
语法:
修饰符 数据类型 属性名 [= 属性值];

属性也叫成员变量(Member Variable),也叫做域(field).

修饰符	   所有类	子类	同包	同类
public     YES		YES	YES	YES	
protected  NO		YES	YES	YES
[]	   NO		NO	YES	YES
private    NO		NO	NO	YES

-------------------------------------------------------

构造方法,也叫做构造器
作用:给属性赋值

构造方法的特点:
a.构造方法的名字必须与类名一致
b.构造方法没有返回类型
c.如果一个类中没有构造方法,则系统会自动创建空参构造
d.如果一个类中已近有构造方法,则系统就不会创建构造了

注:
如果创建对象的时候没有给属性赋值,则系统会分配各数据类型
的默认值给属性

对象类型的默认值一律为null
整数类型	0
浮点型		0.0
布尔类型	false
字符型		\u0000
-------------------------------------------------------
this关键字
作用一:
代表当前对象
一般在构造方法的变量名与属性同名的时候加以区分
this.name = name;

作用二:
可以在构造方法中调用另外一个构造方法
要求:
a.调用的构造方法必须存在
b.this语句必须放在构造方法的第一行

注意:
每个对象都拥有类中的所有非静态的属性和方法
也就是说非静态的属性和方法都是对象所有用的
所以才会有这样的语法:对象名.属性或者对象名.方法

静态方法和静态属性都是类所有用的
所以才会有这样的语法:类名.属性或者类名.方法
------------------------------------------------------

方法的重载(OverLoad)
前提条件:
必须发生在一个类中

要求:
a.方法名必须相同
b.参数列表必须不同
	参数类型不同
	参数的个数不同
	参数的顺序不同
c.返回类型可以不同
d.构造方法允许重载

如:
public class Calc{
	public int add(int i,int j){
		return i + j;
	}

	public double add(double i,double j){
		return i + j;
	}
	//这两个方法构成方法的重载
}
----------------------------------------------------
创建对象的过程(三步):
1.给属性分配空间
2.给属性赋初始值
3.调用构造方法
----------------------------------------------------
JVM的内存结构

分为三部分:堆,栈,代码区

1.栈区(Stack)--先进后出
  大小确定的,效率高,速度快,但是不能动态分配
  一般局部变量存放在栈区
  如:
  int i = 100;
  Scanner sc = new Scanner(System.in);

2.堆区(Heap)--先进先出
  大小不确定,可以动态分配,效率相对较低
  JVM在启动时,可以通过-Xms和-Xmx来配置
  
  -Xms用来设置内存的参数,它用来设置程序初始化的时候
  内存栈的大小,增加这个值,程序的性能会提高,不过,它
  受到Xmx的限制.

  -Xmx是Java的一个选项,用来设置应用程序运行时候能够
  使用的最大内存数,但是不能超过实际物理内存的大小.

  如何在堆空间中申请空间?
  使用new关键字

  一般用来存放对象本身
  所以:
  Scanner sc = new Scanner(System.in);
  Scanner对象本身存在堆空间中,而引用sc存放在栈中(以内存
  地址的形式来存放,它指向堆空间中的Scanner对象本身)
  
3.代码区/永久区
用来存放字节码文件以及方法,还有静态成员
------------------------------------------------------

对象(Object)和引用(Reference)
引用是对象的"句柄",其实引用中存放的就是内存地址

如:
Cup c1;//申请了变量c1,没有创建对象
c1 = new cup();
//此时,在堆空间中创建了一个对象,并且把此对象的内存地址
//赋值给栈区中的引用c1

Cup c2 = new Cup();
c1 = c2;

注:气球理论
一个引用在某一个时间点最多只能指向一个对象
但是,一个对象在某一个时间点可以被多个引用所指向
  
------------------------------------------------------

JVM的垃圾回收机制
它的目的是用来回收"垃圾"对象
也就是没有任何引用所指向的对象

GC(Garbage Collection),它是一种后台守护线程
只要JVM存活,该线程就不会终止

注:GC去回收垃圾对象的时间是不确定的,它有自己的算法
   不能有程序去控制

如:
Cup c1 = new Cup();
...
c2 = null;//此时,gc并不是一定马上去回收垃圾对象
