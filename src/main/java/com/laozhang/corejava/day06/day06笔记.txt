面向对象的三大特性:封装,继承,多态

封装:
a.属性做成私有化的private
b.给属性提供存/取方法,一般命名为getXXX()/setXXX()

注:
给属性赋值有三种方法:
a.直接赋值
b.通过构造方法赋值
c.通过set方法赋值

b.c两种赋值方式是互补的,构造方法只有一次赋值机会,
set方法可以有很多次.set方法还可以做属性值的有效性判断

属性做成私有的,一是为了保护封装性,第二是为了set方法做
值的有效性判断的


封装的策略
实体类:主要是用来存储数据,侧重点在于数据
业务类:主要是用来操作数据,侧重点在于功能

第一种:实体类和业务类结合
第二种:实体类和业务类分开(以后都用这种方式)

案例:见第6天Account1和Account2
------------------------------------------------------

继承(Inheritance)

Java是一种单继承的开发语言,这就意味着Java中任意一个类
最多只能有一个直接的父类

Java使用继承关键字:extends

如:
class Father{}
class Son extends Father{}

类Son继承于Father,
那么Son是子类,也叫做派生类
Father是父类,也叫做超类

问题:Java中父类的父类又是什么呢?
java.lang.Object
是Java中的顶级父类,所有的类都直接或者间接继承与它

注:继承具有传递性
A继承与B,B继承与C,A就继承与C了

Java中不支持直接的多继承(但是可以通过接口和内部类来实现)
[C++支持多继承],所以Java中的继承是线性结构而非网状结构

一个类继承与另一个类,则这个类就拥有了那个类的所有
非静态成员,成员包括属性和方法.

------------------------------------------------------
Super关键字
作用一:
在子类构造中,可以通过super调用父类的指定带参数的构造

注:必须放在构造方法中的第一行

作用二:
如果在子类中的属性与父类中同名时,父类属性会被子类覆盖,
所以,可以通过super.属性名来显式调用父类的属性

注:前提是这个属性不是private的
------------------------------------------------------

使用继承的条件?
基本条件:两个类满足"IS A"的关系,否则,不应该使用继承

如:
dog is animal
apple is fruit

所以,不要光为了代码的复用才胡乱使用继承

注:
尽可能把各个子类中共性的抽象出来,放到父类中,
子类中仅存在特有成员
也就是说,父类保留共性,子类保留特性!
------------------------------------------------------
方法的重写(Override)
前提条件:发生在父子类中,也就是说一定要有继承关系

要求:
a.方法名要相同
b.参数列表也要相同(类型,个数,顺序)
c.返回类型也要相同
d.修饰符必须相同或者低于父类方法的修饰符
e.抛出的异常必须相同或者是父类异常的子类

为什么我们要重写父类的方法?
答:因为父类中的方法是共性方法,不能指代某一具体子类的内容
   换而言之,父类方法不能满足我们的需求,所以要重写.

------------------------------------------------------
多态(Polymorphic)

编译时类型:指对象引用的类型

运行时类型:指对象本身的类型

如:
Animal an = new Dog();
an是引用,它的编译时类型是Animal
而它的运行时类型是Dog,因为创建出来的是Dog对象

注:
父类类型可以作为子类对象的编译时类型
也就是说,Object可以作为任何对象的编译时类型,但是只能
使用Object中的方法.

一个对象,只能使用这个对象编译时类型所含有的属性和方法

所以,为了能够访问到对象的方法,我们应该在父类中提供相应
的方法,然后在子类中重写该方法,最后使用父类做为编译时类
型,子类做为运行时类型,这样就可以调用到该方法,并且程序
运行时,会真正去调用被覆盖的那个方法,这就是多态的体现.


多态的条件:
a.一定要有继承
b.方法重写(静态方法可以重写,但是没有多态性)

instanceof运算符
用法:
	对象 instanceof 类型

如果对象的类型与运算符后面的类型一致,则返回true,
否则返回false

注:
后面的类型只要是对象的父类或者运行时类型都会返回true

在做对象类型强制类型转换前,都要先做instanceof判断
以保证不出现java.lang.ClassCastException异常

------------------------------------------------------

java.lang.Object中的toString()方法

所有类都是直接或者间接继承与Object,所以都会有toString()
方法,而Object的toString()方法返回的是:
类的全限定名@内存地址(hashcode的十六进制形式)
绝大多数情况下,都不能满足我们的打印要求
所以,我们的实体类中,一般都要重写toString()方法,来实现
我们真正的打印内容.
